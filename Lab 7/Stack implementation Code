VISVESVARAYA TECHNOLOGICAL UNIVERSITY 
“JnanaSangama”, Belgaum -590014, Karnataka. 

LAB REPORT 
on 
Data Structures  
(23CS3PCDST)
Submitted by 
          Bhoomi Suresh Kota (1BM23CS065)
in partial fulfillment for the award of the degree of 
BACHELOR OF ENGINEERING 
in 
COMPUTER SCIENCE AND ENGINEERING 

B.M.S. COLLEGE OF ENGINEERING 
(Autonomous Institution under VTU) 
BENGALURU-560019 
   Sep-2024 to Jan-2025 

B.M.S. College of Engineering, 
Bull Temple Road, Bangalore 560019 
(Affiliated To Visvesvaraya Technological University, Belgaum) 
Department of Computer Science and Engineering 

CERTIFICATE 
This is to certify that the Lab work entitled “Object Oriented Java Programming (23CS3PCOOJ)” carried out by Bhoomi Suresh Kota (1BM23CS065), who is a bonafide student of B.M.S. College of Engineering. It is in partial fulfillment for the award of Bachelor of Engineering in Computer Science and Engineering of the Visvesvaraya Technological University, Belgaum during the year 2024-25. The Lab report has been approved as it satisfies the academic requirements in respect of an Data structures Lab (23CS3PCDST) work prescribed for the said degree. 

Dr. Selvakumar S
Associate Professor
Department of CSE, BMSCE


Dr. Kavitha Sooda
Professor and HOD
Department of CSE, BMSCE




 


Index 

Sl. 
No.
Date 
Experiment Title 
Page No.
1






2
3-11-2024
Stack implementation
6
3






4






5






6






7






8






9






10










Course outcomes:

CO1 


Apply the concept of linear and nonlinear data structures.
CO2
Analyze data structure operations for a given problem
CO3
Design and develop solutions using the operations of linear and nonlinear
data structure for a given specification.
CO4
Conduct practical experiments for demonstrating the operations of different data structures.

Program 1

LeetCode: Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

void moveZeroes(int* nums, int numsSize) {
    int temp , zeros = 0;

    for(int ind = 0 ; ind < numsSize ; ind++ ) {
        if( nums[ind] == 0 ) zeros++;
    }

    for(int itr = 0 ; itr < zeros ; itr++ ){
        if ( numsSize > 1 ) {
            for( int ind = 0 ; ind < numsSize ; ind++ ) {
                if( (nums[ind] != 0) && (ind + 1 == numsSize) && (nums[ind-1] == 0) ){
                    temp = nums[ind];
                    nums[ind] = nums[ind-1];
                    nums[ind-1] = temp;
                    break;
                }

                else if( (nums[ind] == 0) && ind == numsSize - 1) break;

                else if(nums[ind] == 0) {
                    temp = nums[ind];
                    nums[ind] = nums[ind+1];
                    nums[ind+1] = temp;
                }
            }
        }
    }

}



Program 2

Write a program to simulate the working of stack using an array with the following: 
a) Push b) Pop c) Display
The program should print appropriate messages for stack overflow, stack underflow 

Code:
#include <stdio.h>
#include <stdlib.h>
#define size 10

void push(int);
void pop();
void display();

int s[size], top=-1;

int main() {
    while(1){
    int op, x;
    printf("Choice");
    printf("\n1.Push \n2.Pop \n3.Display \n4.Exit\n\n");
    scanf("%d", &op);
    switch(op){
        case 1: printf("Enter no.\n");
                scanf("%d", &x);
                push(x);
                break;
        case 2: pop();
                break;
        case 3: display();
                break;
        case 4: exit(0);
               break;
        default: printf("Wrong option!\n");
    }
 }
}

void push(int x){
    if(top==size-1)
    {
        printf("Stack overflow\n");
    }
    else
    {
        top++;
        s[top] = x;
        printf("\nSuccess\n\n");
    }
}

void pop(){
    if(top==-1)
    {
        printf("Stack underflow");
    }
    else
    {
        printf("\nDeleted %d\n", s[top]);
        top--;
        printf("\nSuccess\n\n");
    }
}

void display(){
    if(top==-1)
    {
        printf("\nEmpty\n");
    }
    else
    {
        int i;
        printf("\n\nStack elements are:\n");
        for(i=top;i>=0;i--)
        {
            printf("%d, ", s[i]);
        }
        printf("\n");
    }
}







Output:








Program 3

Code:
#include <stdio.h>
#include <ctype.h>
#define SIZE 50
char stack [SIZE];
int top=-1; /* Global declarations */
int push(char elem) {
stack [++top]=elem; /* Function for PUSH operation */
}
char pop() {
 return(stack[top--]); /*Function for POP operation */
}
int pr(char symbol){ /*Function for precedence */
   if(symbol == '^')/* exponent operator, highest precedence*/
   {
     return (3);
   } 
   else if(symbol == '*' || symbol == '/')
   {
     return (2);
   }
   else if(symbol == '+' || symbol == '-') /* lowest precedence */
   { 
     return(1);
   }
   else
   { 
     return(0);
   }
}
/* Main Program */
void main()
{
   char infix [50],postfix [50],ch,elem;
   int i=0,k=0;
   printf("Enter Infix Expression: "); 
   scanf("%s", infix);
   push('#');
   while((ch=infix[i++]) != '\0')
   {
      if(ch == '(') 
        push(ch);
      else if(isalnum(ch)) 
        postfix [k++]=ch;
      else if(ch == ')')
      {
        while(stack [top] != '(') 
           postfix [k++]=pop();
           elem=pop(); /* Remove (*/
      } 
      else
      { /* Operator */
        while(pr(stack [top]) >= pr(ch))
            postfix[ k++]=pop();
        push(ch);
      }
    }
    while(stack [top] != '#') /* Pop from stack till empty */
        postfix [k++]=pop(); 
    postfix[k]='\0'; /* Make postfix as valid string */ 
    printf("\nPostfix Expression = %s\n", postfix);}
Output:


Program 4

Code:
#include <stdio.h>
#include <stdlib.h>
#define MAX 50
int queue_array[MAX];
int rear = -1;
int front = -1;
int display()
{
  int i;
  if (front == -1)
    printf("Queue is empty \n");
  else
  {
    printf("Queue is :");
    for (i = front; i <= rear; i++)
       printf("%d ", queue_array[i]);
    printf("\n");
  }
} /*End of display() */

int insert()
{
  int add_item;
  if (rear == MAX - 1)
    printf("Queue Overflow \n");
  else
  {
    if (front == -1) /*If queue is initially empty */
      front = 0;
    printf("Insert the element in queue : ");
    scanf("%d", &add_item);
    rear = rear + 1;
    queue_array[rear] = add_item;
  }
} /*End of insert()*/

int del()
{
if (front == - 1 || front > rear)
{
printf("Queue Underflow \n");
return;
}
else
{
printf("Deleted Element is: %d\n", queue_array[front]);
front = front + 1;
}
} /*End of delete() */

void main()
{
int choice;
while (1)
{
printf("1.Insert \n");
printf("2.Delete\n");
printf("3.Display \n");
printf("4.Exit \n");
printf("Enter your choice: ");
scanf("%d", &choice);
switch (choice)
{case 1:
insert();
break;
case 2:
del();
break;
case 3:
display();
break;
case 4:
exit(1);
default:
printf("Inavlid choice \n");
} /*End of switch*/
} /*End of while*/
} /*End of main()*/
#include <stdio.h>
#define SIZE 5
int items [SIZE];
int front= -1, rear = -1;
// Check if the queue is full
int isFull() {
if ((front == rear + 1) || (front == 0 && rear == SIZE - 1)) return 1;
return 0;
}
// Check if the queue is empty
int isEmpty() {
if (front == -1) return 1;
return 0;
}

void enQueue(int element) {
if (isFull())
printf("\n Queue is full!! \n");
else {
if (front == -1) front = 0;
rear = (rear + 1) % SIZE;
items[rear] = element;
printf("\n Inserted -> %d\n", element);
}
}

int deQueue() {
int element;
if (isEmpty()) {
printf("\n Queue is empty !! \n");
return (-1);
} else {
element = items [front];
if (front == rear) {
front = -1;
rear = -1;
}
// Q has only one element, so we reset the
// queue after dequeing it. ?
else {
front = (front + 1) % SIZE;
}
printf("\n Deleted element -> %d \n", element);
return (element);
}
}

// Display the queue
void display() {
int i;
if (isEmpty())
printf(" \n Empty Queue\n");
else {
printf("\n Front -> %d", front);
printf("\n Items -> ");
for (i = front; i != rear; i = (i + 1) % SIZE) {
printf("%d ", items[i]);
}
printf("%d", items[i]);
printf("\n Rear -> %d \n", rear);
}
}
void main()
{
int choice, add_item;
while (1)
{
printf("1.Insert \n");
printf("2.Delete\n");
printf("3.Display \n");
printf("4.Exit \n");
printf("Enter your choice: ");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("Insert the element in queue : ");
scanf("%d", &add_item);
enQueue(add_item);
break;
case 2:
deQueue();
break;
case 3:
display();
break;
case 4:
exit(1);
default:
printf("Inavlid choice \n");
} /*End of switch*/
} /*End of while*/
} /*End of main()*/


Output:












Program 5
Code:
#include<stdio.h>
#include<stdlib.h>
struct Node{
    int data;
    struct Node*next;
};
void push(struct Node**head_ref, int new_data) {
struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
new_node->data = new_data;
new_node->next = (*head_ref);
(*head_ref) = new_node;
}
void AppendAtLast(struct Node**head_ref,int new_data)
{
   struct Node*new_node = (struct Node*) malloc(sizeof(struct Node));
   struct Node*last=*head_ref;
   new_node->data=new_data;
   new_node->next=NULL;
   if(*head_ref==NULL)
   {
      *head_ref=new_node;
      return;
   }
   while(last->next!=NULL)
   {
      last=last->next;
      last->next=new_node;
      return;
   }
}
void AppendatPos(struct Node**head_ref,int pos,int new_data){
   struct Node*new_node = (struct Node*) malloc(sizeof(struct Node));
   new_node->data=new_data;
   struct Node*temp=*head_ref;
   if(pos==1)
   {
     new_node->next=temp;
     *head_ref=new_node;
     return;
   }
   for(int i=1;i<pos-1;i++)
    {
      temp=temp->next;
      new_node->next=temp->next;
      temp->next=new_node->next;
    }
   }
void PrintList(struct Node*node)
{
    while(node!=NULL)
    {
        printf("%d\n",node->data);
        node=node->next;
    }
}

int main()
{
    struct Node*head=NULL;
    AppendAtLast(&head,6);
    push(&head,7);
    push(&head,1);
    AppendatPos(&head,4,7);
    printf("\nCreated LInked list is:\n");
    PrintList(head);
    return 0;
}



Output:















LeetCode:
https://leetcode.com/problems/backspace-string-compare/description/?envType=problem-list-v2&envId=stack

#define SIZE 100
int top=-1;
char stack[SIZE];
void push(char c)
{
    if(top==SIZE-1)
    {
        printf("full");
    }

    else
    {
        stack[++top]=c;
    }
}

char pop()
{
    if(top==-1) return '\0';
    return stack[top--];
}

bool backspaceCompare(char* s, char* t) {
    char str_t[100];
    char string_s[100];
    while(*s!='\0')
    {
    if(*s=='#') pop();
    else push(*s);
    s++;
    }
    for(int i=top; i>=0;i--)
    {
        string_s[i] = pop();
    }

    top=-1;

    while(*t!='\0')
    {
    if(*t=='#') pop();
    else push(*t);
    t++;
    }
    for(int i=top; i>=0;i--)
    {
        str_t[i] = pop();
    }
    if(strcmp(string_s,str_t)==0)
    {
        return 1;
    }
    else return 0;    
}

Program 6

Code:

#include<stdio.h>
#include<stdlib.h>
struct node
{
  int data;
  struct node *next;
};

struct node *head;

void begin_insert();
void begin_delete();
void last_delete();
void random_delete();
void display();

void main()
{
    int choice =0;
    while(1)
    {
        printf("\nChoose an option: ");
        printf("\n1.Insert in the beginning\n2.Delete in the beginning\n3.Delete at last\n4.Delete at random\n5.Display\n6.Exit ");
        printf("\nEnter choice: ");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1: begin_insert(); break;
            case 2: begin_delete(); break;
            case 3: last_delete(); break;
            case 4: random_delete(); break;
            case 5: display(); break;
            case 6: exit(0);
        }

    }
}

void begin_insert(){
    int new_data;
    struct node *new = (struct node*) malloc(sizeof(struct node));
    printf("\nEnter data: ");
    scanf("%d", &new_data);
    new->data = new_data;
    new->next = head;
    head = new;
}

void begin_delete(){
    struct node *ptr;
    if(head==NULL)
    {
        printf("Empty list");
    }
    else
    {
        ptr = head;
        head = ptr->next;
        free(ptr);
    }
}

void last_delete()
{
    struct node *ptr, *ptr1;
    if(head==NULL)
    {
        printf("Empty list");
    }
    else if(head->next == NULL)
    {
        head = NULL;
        free(head);
    }
    else
    {
        ptr = head;
        while(ptr->next != NULL)
        {
            ptr1 = ptr;
            ptr = ptr -> next;
        }
        ptr1 -> next = NULL;
        free(ptr);
    }
}

void random_delete()
{
    struct node *ptr, *ptr1;
    int loc, i;
    printf("\nEnter location: ");
    scanf("%d", &loc);
    ptr=head;
    for(i=0;i<loc;i++)
    {
        ptr1 = ptr;
        ptr=ptr->next;
    }
    if(ptr==NULL)
    {
        printf("\nCannot delete");
        return;
    }
    ptr1->next = ptr ->next;
    free(ptr);
    printf("\nDeleted node %d", loc+1);

}

void display()
{
    struct node *ptr;
    ptr = head;
    if(ptr == NULL)
    {
        printf("Empty List");
    }
    else
    {
        printf("List is: \n");
        while(ptr!=NULL)
        {
            printf("\n %d", ptr->data);
            ptr = ptr->next;
        }
    }
}

Output:




























LeetCode:

//Problem1

struct ListNode* deleteDuplicates(struct ListNode* head) {
    if (head == NULL) {
        return NULL;  // If the list is empty, return NULL
    }

    struct ListNode *ptr = head;  // Initialize pointer to head

    // Traverse the list while there's a next node
    while (ptr != NULL && ptr->next != NULL) {
        // If current node value equals the next node's value, remove the next node
        if (ptr->val == ptr->next->val) {
            struct ListNode *temp = ptr->next;
            ptr->next = ptr->next->next;  // Skip the duplicate node
            free(temp);  // Free the memory of the removed node
        } else {
            // Move to the next node if no duplicate is found
            ptr = ptr->next;
        }
    }

    return head;
}

//Problem2

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool isPalindrome(struct ListNode* head) {
    int arr[10000];  // You can adjust this if needed, but ideally should be dynamic
    int i = 0, count = 0;
    struct ListNode* ptr = head;

    // Step 1: Store list values in arr[] and count the length
    while(ptr != NULL) {
        arr[i] = ptr->val;
        ptr = ptr->next;
        i++;
        count++;
    }

    // Step 2: Reverse the array values into arr2[]
    int arr2[10000];
    for(i = 0; i < count; i++) {
        arr2[i] = arr[count - 1 - i];
    }

    // Step 3: Compare arr[] and arr2[]
    for(i = 0; i < count; i++) {
        if(arr[i] != arr2[i]) {
            return false;  // Return false if any mismatch is found
        }
    }

    // Step 4: Return true if all elements match
    return true;
}
Program 7
Code:

#include<stdio.h>
#include<conio.h>

struct node{
    int data;
    struct node *next;
};

struct node *head = NULL;
struct node *head1 = NULL;

void insert(int x){
    struct node *new_node = (struct node *)malloc(sizeof(struct node));
    new_node -> data = x;
    new_node -> next = NULL;
    if(head==NULL)
    {
        head = new_node;
    }
    else{
        struct node *temp = head;
        while(temp -> next != NULL)
            temp = temp -> next;
        temp -> next = new_node;
    }
}

void insert2(int x){
    struct node *new_node = (struct node *)malloc(sizeof(struct node));
    new_node -> data = x;
    new_node -> next = NULL;
    if(head1==NULL)
    {
        head1 = new_node;
    }
    else{
        struct node *temp = head1;
        while(temp -> next != NULL)
            temp = temp -> next;
        temp -> next = new_node;
    }
}

struct node *sort(struct node *head)
{
        struct node *ptr = head;
        struct node *nextptr = head;
        int item;
        if(ptr == NULL)
        {
            printf("Empty");
            return;
        }

        for(ptr=head; ptr!=NULL; ptr=ptr->next)
        {
            for(nextptr=ptr->next; nextptr!=NULL; nextptr=nextptr->next)
            {
                if(ptr->data > nextptr -> data)
                {
                    item = ptr->data;
                    ptr -> data = nextptr -> data;
                    nextptr -> data = item;
                }
            }
        }
        return(head);
}

struct node *concatenate(struct node *head, struct node *head1)
{
        if(head1!=NULL && head1!=NULL)
        {
            if(head->next==NULL)
            {
                head->next=head1;
            }
            else concatenate(head->next, head1);
        }
        else printf("Either of them is empty");
        return(head);
}

struct node *reverse(struct node *head)
{
        struct node *prev = NULL;
        struct node *next = NULL;
        struct node *current = head;
        while(current!=NULL)
        {
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        head = prev;
        return(head);
}

void display(struct node *head)
{
    struct node *ptr = head;
    while(ptr != NULL)
    {
        printf("%d ", ptr->data);
        ptr = ptr->next;
    }
    printf("\n");
}

void main(){
    insert(30);
    insert(43);
    insert(55);
    insert(16);
    insert(14);
    display(head);

    insert2(12);
    insert2(40);
    insert2(65);
    insert2(1);
    insert2(14);
    display(head1);

    struct node *a = sort(head);
    printf("Sorted list 1: ");
    display(a);
    struct node *b=sort(head1);
    display(b);
    struct node *c=concatenate(a, b);
    display(c);
    struct node *d=reverse(c);
    display(d);
}



#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

struct Node{
    int data;
    struct Node *next;
};

void push(struct Node** head, int new_data)
{
struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
new_node->data = new_data;
new_node->next = *head;
*head = new_node;
}
void pop(struct Node** head)
{
struct Node *ptr;
if(*head == NULL)
{
printf("\nList is empty");
}
else
{
ptr = *head;
*head = ptr->next;
free(ptr);
//printf("\n Node deleted from the begining ...");
}
}

void display(struct Node* head) {
    struct Node* current = head;
    if(head == NULL) {
        printf("\nList is empty\n");
        return;
    }
    printf("\nList: ");
    while(current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

void main(){
   struct Node *head = NULL;
   push(&head, 30);
   push(&head, 40);
   push(&head, 50);
   push(&head, 60);
   display(head);
   pop(&head);
   display(head);
}


Program 8
Program 9
Program 10

